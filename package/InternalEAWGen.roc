## The purpose of this file is to generate the InternalEAW.roc file.
##
## This file will read the test data from `data/EastAsianWidth-15.1.0.txt`
## parse it and then generate function to test the East Asian Width property of a code point.
app [main] {
    pf: platform "https://github.com/roc-lang/basic-cli/releases/download/0.17.0/lZFLstMUCUvd5bjnnpYromZJXkQUrdhbva4xdBInicE.tar.br",
}

import pf.File
import pf.Arg
import "data/EastAsianWidth-15.1.0.txt" as file : Str
import Helpers

EawRange : (Str, Str, Str)

main =
    when Arg.list! {} |> List.get 1 is
        Err _ -> Task.err (InvalidArguments "USAGE: roc run InternalEAWGen.roc -- path/to/package/")
        Ok arg -> File.writeUtf8 "$(Helpers.removeTrailingSlash arg)/InternalEAW.roc" template

template =
    """
    ## WARNING This file is automatically generated. Do not edit it manually. ##
    module [eastAsianWidthProperty, eastAsianWidth]

    eastAsianWidth : U32 -> U32
    eastAsianWidth = \\codePoint ->
        when eastAsianWidthProperty codePoint is
            F | W | A -> 2
            H | N | Na -> 1

    eastAsianWidthProperty = \\cp -> $(testsStr)

    $(allTests)
    """

# The ranges are specified as its starting point and an optional inclusive end point
# if it's length is greater than 1. The range is followed by the East_Asian_Width property
# separated by a semicolon.
# Examples:
# 0000..001F     ; N    # The property may be followed by comments
# 0020           ; Na
parseLine : Str -> Result EawRange _
parseLine = \line ->
    listToParsingState = \rest -> { val: [], rest }

    startHexBytes =
        line
        |> Str.toUtf8
        |> listToParsingState
        |> Helpers.takeHexBytes

    endHexBytes =
        when startHexBytes.rest is
            ['.', '.', .. as rest] -> rest |> listToParsingState |> Helpers.takeHexBytes
            _ -> startHexBytes # This range has length 1. The start will be repeated as the end

    endHexBytes.rest
    |> List.splitFirst ';'
    |> Result.map \{ after } -> after
    |> Result.try \commentdEAP -> List.splitFirst commentdEAP '#'
    |> Result.map \{ before } -> before
    |> Result.try Str.fromUtf8
    |> Result.map Str.trim
    |> Result.try \eawp ->
        startHexBytes.val
        |> Str.fromUtf8
        |> Result.map \start -> (eawp, "0x$(start)")
    |> Result.try \(eawp, start) ->
        endHexBytes.val
        |> Str.fromUtf8
        |> Result.map \end -> (eawp, start, "0x$(end)")

expect parseLine "0020           ; Na # Zs         SPACE" == Ok ("Na", "0x0020", "0x0020")
expect parseLine "0025..0027     ; Na # Po     [3] PERCENT SIGN..APOSTROPHE" == Ok ("Na", "0x0025", "0x0027")

parsedLines : List (Result EawRange _)
parsedLines = file |> Str.splitOn "\n" |> List.map parseLine

originalRanges =
    parsedLines
    |> List.keepOks \x -> x

# We can drop the Neutral ranges because those are the default
optimizedRanges =
    List.dropIf originalRanges \(eawp, _, _) -> eawp == "N"

# The input file contains many consecutive ranges with the same property value.
# We will merge them into wider ranges to work with a smaller number of ranges.
mergedRanges =
    headRes = List.first optimizedRanges
    tail = List.dropFirst optimizedRanges 1
    res =
        when headRes is
            Err _ -> crash "Something went wrong while parsing the input."
            Ok head -> List.walk tail { merged: [], merging: head } mergeOp

    List.append res.merged res.merging

mergeOp : { merged : List EawRange, merging : EawRange }, EawRange -> { merged : List EawRange, merging : EawRange }
mergeOp = \{ merged, merging }, currentValue ->
    if merging.0 == currentValue.0 && (Helpers.hexStrToU32 merging.2) + 1 == (Helpers.hexStrToU32 currentValue.1) then
        {
            merged,
            merging: (merging.0, merging.1, currentValue.2),
        }
    else
        {
            merged: List.append merged merging,
            merging: currentValue,
        }

expect mergeOp { merged: [], merging: ("Na", "0x0020", "0x0020") } ("Na", "0x0021", "0x0021") == { merged: [], merging: ("Na", "0x0020", "0x0021") }
expect mergeOp { merged: [], merging: ("Na", "0x0020", "0x0020") } ("Na", "0x0022", "0x0022") == { merged: [("Na", "0x0020", "0x0020")], merging: ("Na", "0x0022", "0x0022") }

# Ranges grouped by the values of their property
groupedRanges : Dict Str (List (Str, Str))
groupedRanges =
    mergedRanges
    |> List.walk (Dict.empty {}) \s, range ->
        Dict.update s range.0 \value ->
            when value is
                Ok lst -> Ok (List.append lst (range.1, range.2))
                Err Missing -> Ok (List.single (range.1, range.2))

testsStr : Str
testsStr =
    rangeToTestStr = \(start, end) ->
        if start == end then
            "cp == $(start)"
        else
            "($(start) <= cp && cp <= $(end))"
    groupedRanges
    |> Dict.map \_, lst ->
        (List.map lst rangeToTestStr)
        |> Str.joinWith " || "
    |> Dict.map \eawp, test ->
        "if $(test) then ($(eawp))"
    |> Dict.values
    |> Str.joinWith " else "
    |> Str.concat " else N"

createTest : (U32, Str) -> Str
createTest = \(cp, eawp) ->
    "expect eastAsianWidthProperty $(Num.toStr cp) == $(eawp)"

expect
    test = createTest ('Æ', "A")
    expected = "expect eastAsianWidthProperty 198 == A"
    test == expected

allTests =
    tests = [
        # Ambiguous
        ('Æ', "A"),
        ('ⓩ', "A"),
        ('☎', "A"),
        # Halfwidth
        ('₩', "H"),
        ('｣', "H"),
        # Narrow
        ('¢', "Na"),
        ('¥', "Na"),
        ('¬', "Na"),
        # Wide
        ('〇', "W"),
        ('〡', "W"),
        ('〩', "W"),
        ('﹄', "W"),
        ('﹉', "W"),
        ('你', "W"),
        # Fullwidth
        ('Ａ', "F"),
        ('￦', "F"),
        # Neutral
        ('𑈸', "N"),
        ('𑌓', "N"),
        ('𑪊', "N"),
    ]
    List.map tests createTest |> Str.joinWith "\n\n"
